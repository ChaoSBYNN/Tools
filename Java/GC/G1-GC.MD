# G1 GC

## What is G1

> `G1 (Garbage-First)` 主要针对配备多核CPU及大容量内存的机器,以极高概率满足GC停顿时间的同时,还兼具高吞吐量的性能特征

1. G1是一个`并行回收器`,它把`堆内存分割为很多不相关的区域(region物理上不连续),把堆分为2048个区域`,每一个region的大小是1 - 32M不等,必须是`2的整数次幂`。使用不同的region可以来表示Eden、幸存者0区、幸存者1区、老年代等 (有点像Apple M1芯片)
2. 每次根据允许的收集时间,`优先回收价值最大的Region`(每次回收完以后都有一个空闲的region,在后台维护一个优先列表)
3. 由于这种方式的侧重点在于回收垃圾最大量的区间(Region),所以我们给G1一个名字:垃圾优先(Garbage First)
4. 既然我们已经有了前面几个强大的GC,为什么还要发布Garbage First(G1)GC？: 官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量,所以才担当起"全功能收集器"的重任与期望。

## What is Region : 化整为零

![Region](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00269e5e4dcf463da7ff2eb0b8368fc3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

- 使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB,2MB, 4MB, 8MB, 1 6MB, 32MB。可以通过-XX :G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。
- 虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了,它们都是一部分Region (不需要连续)的集合。通过Region的动态分配方式实现逻辑上的连续。
- 一个region有可能属于Eden， Survivor 或者0ld/Tenured 内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，s表示属于Survivor内存区域，o表示属于old内存区域。图中空白的表示未使用的内存空间。
- G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个region, 就放到H。
- 设置H的原因:对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。 G1的大多数行为都把H区作为老年代的一部分来看待。

## G1 Feature

1. 并行和并发
   - 并行性: G1在回收期间,可以有多个GC线程同时工作,有效利用多核计算能力。此时用户线程STW
   - 并发性: G1拥有与应用程序交替执行的能力,部分工作可以和应用程序同时执行,因此,一般来说,不会在整个回收阶段发生完全阻塞应用程序的情况
2. 分代收集
   - 从分代上看,G1依然属于分代型垃圾回收器,它会区分年轻代和老年代,年轻代依然有Eden区和Survivor区。但从堆的结构上看,它不要求整个Eden区、年轻代或者老年代都是连续的,也不再坚持固定大小和固定数量。
   - 将堆空间分为若干个区域(Region),这些区域中包含了逻辑上的年轻代和老年代。
   - 和之前的各类回收器不同,它同时兼顾年轻代和老年代。对比其他回收器,或者工作在年轻代,或者工作在老年代
    ![Forget it](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5330761237444d7aec5982d9a66e62f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)
    ![Use it](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d59f816eba634158a0a5aaf21000261d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)
3. 空间整合
   - G1将内存划分为一个个的region。 内存的回收是以region作为基本单位的。Region之间是复制算法,但整体上实际可看作是标记一压缩(Mark一Compact)算法,两种算法都可以避免内存碎片。这种特性有利于程序长时间运行,分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候,G1的优势更加明显
4. 可预测的停顿时间模型(即:软实时soft real一time) : 这是 G1 相对于 CMS 的另一大优势,G1除了追求低停顿外,还能建立可预测的停顿时间模型,能让使用者明确指定在一个长度为 M 毫秒的时间片段内,消耗在垃圾收集上的时间不得超过 N 毫秒、可以通过参数**-XX:MaxGCPauseMillis**进行设置
   - 由于分区的原因,G1可以只选取部分区域进行内存回收,这样缩小了回收的范围,因此对于全局停顿情况的发生也能得到较好的控制
   - G1 跟踪各个 Region 里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值),在后台维护一个优先列表,每次根据允许的收集时间,优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。
   - 相比于CMS GC,G1未必能做到CMS在最好情况下的延时停顿,但是最差情况要好很多
5. 缺点
   - 相较于CMS,G1还不具备全方位、压倒性优势。比如在用户程序运行过程中,G1无论是为了垃圾收集产生的内存占用(Footprint)还是程序运行时的额外执行负载(Overload)都要比CMS要高。
   - 从经验上来说,在小内存应用上CMS的表现大概率会优于G1,而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间

## G1 Properties

- `-XX:+UseG1GC`:手动指定使用G1收集器执行内存回收任务（JDK9后不用设置，默认就是G1）
- `-XX:G1HeapRegionSize`:设置每个Region的大小。值是2的幂,范围是1MB到32MB之间,目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000
- `-XX:MaxGCPauseMillis`:设置期望达到的最大GC停顿时间指标(JVM会尽力实现,但不保证达到)。默认值是200ms（如果这个值设置很小,如20ms,那么它收集的region会少,这样长时间后,堆内存会满。产生FullGC,FullGC会出现STW,反而影响用户体验)
- `-XX:ParallelGCThread`:设置STW时GC线程数的值。最多设置为8(垃圾回收线程)
- `-XX:ConcGCThreads`:设置并发标记的线程数。将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右
- `-XX:InitiatingHeapOccupancyPercent`:设置触发并发GC周期的Java堆占用率阈值。超过此值,就触发GC。默认值是45

## Where ues G1

