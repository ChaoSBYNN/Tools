# 六边形架构

> 分层系统是一种架构风格，本质是避免耦合的出现。

2005年Alistair Cockburn提出了六边形架构，在这个架构中，将应用分为内六边形和外六边形两层，内六边形实现应用的核心业务逻辑。外六边形完成外部应用，基础资源等的交互和访问，对于与不同的外部系统交互，由外六边形的适配器负责协议转换，保证内六边形业务逻辑的干净。

这种架构也是典型的分层架构，和DDD分层架构一样，都体现了高内聚，低耦合的设计特性。六边形也常作为指导微服务设计的重要架构之一。

六边形架构遵循了分层系统的所有约束与特性，其实用端口和适配器架构这个名称更合适，因为六边形的边的数目并没有任何意义。

![六边形](https://img2020.cnblogs.com/blog/1135193/202105/1135193-20210531121458344-516091878.png)

## 六边形架构 (端口与适配器)

1. 一种具有对称性特征的架构风格。
2. 在这种架构中不同的客户通过“平等”的方式与系统交互。
3. 新客户的加入，只需要添加一个新的适配器将客户输入转化成能被系统 API 所理解的参数就行了。
4. 系统输出（图形界面、持久化和消息等）都有一个新建的适配器负责完成相应的转化功能。

> 可以将资源库的实现看作是持久化适配器，该适配器用于访问先前存储的聚合实例，或者保存新的聚合实例。
> 正如图中的适配器E、F 和 G 所展示的，可以通过不同的方式实现资源库，比如关系型数据库、基于文档的存储、分布式缓存和内存存储等。
> 如果应用程序向外界发送领域事件消息，我们将使用适配器 H 进行处理。

### 六边形架构的三个层

1. 领域层 : 领域模型包含了所有的应用逻辑与规则。 领域层中不会直接引用技术实现，例如 HTTP 上下文或数据库调用，这样就能够确保在技术方面的改动不会影响到领域层面。
2. 端口层 : 负责接收与用例相关的所有请求，这些请求负责在领域层中协调工作。 端口层在端口内部作为领域层的边界，在端口外部则扮演了外部实体的角色。
3. 适配器层 : 这一层的技术实现负责以某种格式接收输入、及产生输出。 在适配器层不存在领域逻辑，它的唯一职责就是在外部世界与领域层之间进行技术性的转换。

### 六边形架构优点

1. 可以轻易的开发用于测试的适配器。
2. 应用程序和领域模型可以在没有客户和存储机制的条件下进行设计开发。
3. 任何测试客户都可以在用户解密还未完成之前进行开发。
4. 选择持久化机制之前，可以在测试中采用内存资源库来模拟持久化。
5. 如此可以在核心领域上进行持续开发，不需要考虑那些支撑性的技术组件。

### 六边形架构核心思想

1. 关注点分离
  - 重心放在领域业务逻辑上，因为领域的业务逻辑相对更加稳定，体现应用的核心价值，应当优先详尽的设计与测试。
  - 外部的输入驱动逻辑和输出给外部的被驱动逻辑存在可变性、可替换性，同时可以依赖多种不同的具体技术实现，可以在后一个阶段考虑。
  - 实际研发过程中还存在输出的外部系统还没有设计与开发好的情况，此时在节奏上也不匹配，可能只有对方的设计文档，甚至更严重的情况下设计文档都没。
  - 输出的外部系统存在多种不同类型的可能，例如在有些情况下你对接的是 OpenStack，有些情况下对接的是 VMware 。
2. 外部可替换
  - 内部不关心外部如何使用端口，外部使用者是可替换的这个原则一开始设计的时候就需要遵守。
  - 适配器可以分为2类，“驱动者适配器”和“被驱动者适配器”，也可以称为“输入型适配器”和“输出型适配器”。
  - 输出型适配器从表面上看似乎是内部在使用外部，与外部可替换的原则有冲突，这个问题实际上需要通过“依赖倒置”解决。
3. 依赖倒置
  - 六边形架构必须遵循的规则：内部相关的代码不能泄露到外部。
  - 所谓的泄露是指不能出现内部依赖外部的情况，只能外部依赖内部，这样才能保证外部是可以替换的。
  - 对于驱动者适配器就是外部依赖内部的，但是对于被驱动者适配器，实际是内部依赖外部。
  - 该问题需要使用依赖倒置，由驱动者适配器将被驱动者适配器注入到应用内部，这时端口的定义在应用内部，但是实现是由适配器实现。
4. 可测试性
  - 自动化测试的便利性是需要着重优先考虑的。
  - 内六边形中的应用程序应当可以在不依赖外部的情况下自行测试。





