# 六边形架构

`分层系统是一种架构风格，本质是避免耦合的出现。`

2005年Alistair Cockburn提出了六边形架构，在这个架构中，将应用分为内六边形和外六边形两层，内六边形实现应用的核心业务逻辑。外六边形完成外部应用，基础资源等的交互和访问，对于与不同的外部系统交互，由外六边形的适配器负责协议转换，保证内六边形业务逻辑的干净。六边形架构(Hexagonal Architecture), 又叫做端口适配器模式(Ports & Adapters)

> Allow an application to equally be driven by users, programs, automated test or batch scripts, and to be developed and tested in isolation from its eventual run-time devices and databases.

这种架构也是典型的分层架构，和DDD分层架构一样，都体现了高内聚，低耦合的设计特性。六边形也常作为指导微服务设计的重要架构之一。

六边形架构遵循了分层系统的所有约束与特性，其实用端口和适配器架构这个名称更合适，因为六边形的边的数目并没有任何意义。

![六边形](https://img2020.cnblogs.com/blog/1135193/202105/1135193-20210531121458344-516091878.png)

## 六边形架构 (端口与适配器)

### Why 为什么会出现六边形架构？

多年来，软件应用程序的最大缺陷之一是业务逻辑渗透到用户界面代码中。 这引起的问题有三个方面：

1. 首先，无法使用自动化测试套件对系统进行完整的测试，因为需要测试的部分逻辑依赖于经常变化的视觉细节，例如字段大小和按钮位置。
2. 出于完全相同的原因，不可能从人工驱动的系统转换为批处理运行的系统。
3. 出于同样的原因，当程序耦合度逐渐增高时，很难或不可能允许该程序被另一个程序驱动。

在许多组织中反复尝试的解决方案是在体系结构中创建一个新层，并保证这次确实没有将业务逻辑放入新层中。 但是，由于没有机制来检测何时发生违反该承诺的情况，该组织发现，几年后，新层被业务逻辑弄得乱七八糟，旧问题又出现了。

我们知道，电脑与周边设备是通过端口与驱动（适配器）交互的，且只需要有相应的驱动，端口可以和不同的设备进行交互。`六边形架构关注的是“外部”和“内部”的差别，内部业务逻辑（Application)与外设（APP,WEB，数据库等）完全隔离，仅通过Adapter 进行交互。`

-------------------------------------------

### What 架构思想

1. 一种具有对称性特征的架构风格。
2. 在这种架构中不同的客户通过“平等”的方式与系统交互。
3. 新客户的加入，只需要添加一个新的适配器将客户输入转化成能被系统 API 所理解的参数就行了。
4. 系统输出（图形界面、持久化和消息等）都有一个新建的适配器负责完成相应的转化功能。

> 可以将资源库的实现看作是持久化适配器，该适配器用于访问先前存储的聚合实例，或者保存新的聚合实例。
> 正如图中的适配器E、F 和 G 所展示的，可以通过不同的方式实现资源库，比如关系型数据库、基于文档的存储、分布式缓存和内存存储等。
> 如果应用程序向外界发送领域事件消息，我们将使用适配器 H 进行处理。

### 六边形架构的三个层

1. 领域层 : 领域模型包含了所有的应用逻辑与规则。 领域层中不会直接引用技术实现，例如 HTTP 上下文或数据库调用，这样就能够确保在技术方面的改动不会影响到领域层面。
2. 端口层 : 负责接收与用例相关的所有请求，这些请求负责在领域层中协调工作。 端口层在端口内部作为领域层的边界，在端口外部则扮演了外部实体的角色。
3. 适配器层 : 这一层的技术实现负责以某种格式接收输入、及产生输出。 在适配器层不存在领域逻辑，它的唯一职责就是在外部世界与领域层之间进行技术性的转换。

### 六边形架构优点

1. 可以轻易的开发用于测试的适配器。
2. 应用程序和领域模型可以在没有客户和存储机制的条件下进行设计开发。
3. 任何测试客户都可以在用户解密还未完成之前进行开发。
4. 选择持久化机制之前，可以在测试中采用内存资源库来模拟持久化。
5. 如此可以在核心领域上进行持续开发，不需要考虑那些支撑性的技术组件。

### 六边形架构核心思想

1. 关注点分离
  - 重心放在领域业务逻辑上，因为领域的业务逻辑相对更加稳定，体现应用的核心价值，应当优先详尽的设计与测试。
  - 外部的输入驱动逻辑和输出给外部的被驱动逻辑存在可变性、可替换性，同时可以依赖多种不同的具体技术实现，可以在后一个阶段考虑。
  - 实际研发过程中还存在输出的外部系统还没有设计与开发好的情况，此时在节奏上也不匹配，可能只有对方的设计文档，甚至更严重的情况下设计文档都没。
  - 输出的外部系统存在多种不同类型的可能，例如在有些情况下你对接的是 OpenStack，有些情况下对接的是 VMware 。
2. 外部可替换
  - 内部不关心外部如何使用端口，外部使用者是可替换的这个原则一开始设计的时候就需要遵守。
  - 适配器可以分为2类，“驱动者适配器”和“被驱动者适配器”，也可以称为“输入型适配器”和“输出型适配器”。
  - 输出型适配器从表面上看似乎是内部在使用外部，与外部可替换的原则有冲突，这个问题实际上需要通过“依赖倒置”解决。
3. 依赖倒置
  - 六边形架构必须遵循的规则：内部相关的代码不能泄露到外部。
  - 所谓的泄露是指不能出现内部依赖外部的情况，只能外部依赖内部，这样才能保证外部是可以替换的。
  - 对于驱动者适配器就是外部依赖内部的，但是对于被驱动者适配器，实际是内部依赖外部。
  - 该问题需要使用依赖倒置，由驱动者适配器将被驱动者适配器注入到应用内部，这时端口的定义在应用内部，但是实现是由适配器实现。
4. 可测试性
  - 自动化测试的便利性是需要着重优先考虑的。
  - 内六边形中的应用程序应当可以在不依赖外部的情况下自行测试。


> - Explicitly separate Application, Domain, and Infrastructure 明确区分应用程序，领域和基础结构三个层
> - Dependencies are going from Application and Infrastructure to the Domain 依赖关系是从应用程序和基础结构再到领域
> - We isolate the boundaries by using Ports and Adapters 使用端口和适配器隔离它们的边界

#### 第一个原则 : 分层

![splite](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jaGFwYW9mYW4tcGljdHVyZS5vc3MtY24taGFuZ3pob3UuYWxpeXVuY3MuY29tL2ltZy9ibG9nLzIwMjAwMjAzMTc0ODIyLnBuZw?x-oss-process=image/format,png)

- `应用程序端(Application)`：这是用户或外部程序将与应用程序进行交互的一面。API 的 HTTP 路由，JSON 序列化都在这里，有点类似于 MVC 的 controller 层。
- `领域(Domain)`：左右两端隔离的部分，它包含所有涉及并实现业务逻辑的代码。
- `基础架构(Infrastructure)`：在这里我们可以找到您的应用程序需要什么，它可以驱动什么工作。它包含基本的基础结构详细信息，例如与数据库交互的代码，对文件系统的调用或处理对您依赖的其他应用程序的 HTTP 调用的代码。

#### 第二个原则 : 依赖关系进入域

简单的说，**一切都依赖于 Domain，而 Domain 不依赖于任何东西**。Alistair Cockburn 坚持内部和外部之间的这种划分，这比应用程序和基础结构之间的差异更具结构性，可以解决最初的问题。

![DI](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jaGFwYW9mYW4tcGljdHVyZS5vc3MtY24taGFuZ3pob3UuYWxpeXVuY3MuY29tL2ltZy9ibG9nLzIwMjAwMjA0MTQyOTI3LnBuZw?x-oss-process=image/format,png)

#### 第三个原则 : 边界与接口隔离

![side](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jaGFwYW9mYW4tcGljdHVyZS5vc3MtY24taGFuZ3pob3UuYWxpeXVuY3MuY29tL2ltZy9ibG9nLzIwMjAwMjA0MTQzMzM1LnBuZw?x-oss-process=image/format,png)

